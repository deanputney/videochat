{"version":3,"sources":["webpack:///./src/js/components/navbar.js","webpack:///./src/js/application.js","webpack:///./src/js/index.js","webpack:///./src/textures/checkerboard.jpg","webpack:///./src/textures/star.png","webpack:///./src/glsl/vertexShader.glsl","webpack:///./src/glsl/fragmentShader.glsl"],"names":["toggleMobileNav","document","querySelector","classList","toggle","checkerboard","require","star","vertexShader","fragmentShader","Application","opts","this","showHelpers","undefined","canvas","getElementById","container","createTooltip","textureLoader","THREE","Detector","bindEventHandlers","init","render","warning","appendChild","handleClick","bind","handleMouseMove","handleResize","showTooltip","hideTooltip","setupLocalVideo","window","addEventListener","setupScene","setupRenderer","setupCamera","Interaction","renderer","scene","camera","setupLights","setupHelpers","setupRay","setupControls","addFloor","addVideoGroup","controls","update","updateVideoCylinder","requestAnimationFrame","main","alert","div","createElement","setAttribute","tooltip","localVideo","console","log","navigator","mediaDevices","getUserMedia","video","width","height","facingMode","then","stream","srcObject","play","catch","error","event","getNDCCoordinates","clientWidth","clientHeight","aspect","updateProjectionMatrix","setSize","interactionEvent","target","name","type","uuid","data","global","x","y","getScreenCoordinates","xScreen","yScreen","innerHTML","style","autoUpdate","getComputedStyle","color","getPropertyValue","background","fog","antialias","setClearColor","setPixelRatio","devicePixelRatio","shadowMap","enabled","domElement","position","set","lookAt","dirLight","castShadow","shadow","near","add","spotLight","ambientLight","gridHelper","axesHelper","getObjectByName","raycaster","geometry","load","texture","wrapS","wrapT","repeat","material","map","side","floor","rotation","Math","PI","cursor","on","OrbitControls","maxDistance","minDistance","autoRotate","gui","DAT","min","max","delta","uniforms","value","vertexDisplacement","Float32Array","attributes","count","i","length","sin","customMesh","needsUpdate","cube","radius","flipY","vc","group","repeatX","videoHeight","videoWidth","offset","numParticles","particleSize","particleSpecs","particles","Array","fill","makeParticle","vertices","alphaTest","size","transparent","particleSystem","numBoxes","boxSpecs","depth","spread","meshes","makeMesh","mesh","debug","offsetLeft","offsetTop","xRelativePx","clientX","yRelativePx","clientY","screenX","screenY","table","xNDC","yNDC","canvasDomRect","getBoundingClientRect","mainDomRect","d","particle","randFloatSpread","z","random","app","vg","RTCMultiConnection","io","connection","socketURL","session","audio","videosContainer","openOrJoin","module","exports"],"mappings":"wFAGO,SAASA,IACFC,SAASC,cAAc,OAC/BC,UAAUC,OAAO,sBALvB,mC,kxBCQA,IAAMC,EAAeC,EAAQ,IACvBC,EAAOD,EAAQ,IACfE,EAAeF,EAAQ,IACvBG,EAAiBH,EAAQ,IAOlBI,EAAb,WACE,WAAYC,GAQV,G,4FARgB,SAChBC,KAAKC,aACHF,QAA6BG,IAArBH,EAAKE,aAA4BF,EAAKE,YAChDD,KAAKG,OAASd,SAASe,eAAe,sBACtCJ,KAAKK,UAAYhB,SAASC,cAAc,gCACxCU,KAAKM,gBACLN,KAAKO,cAAgB,IAAIC,gBAErBC,QACFT,KAAKU,oBACLV,KAAKW,KAAKX,KAAKG,QACfH,KAAKY,aACA,CAEL,IAAMC,EAAUJ,yBAChBT,KAAKK,UAAUS,YAAYD,I,UAhBjC,O,EAAA,G,EAAA,2CAwBIb,KAAKe,YAAcf,KAAKe,YAAYC,KAAKhB,MACzCA,KAAKiB,gBAAkBjB,KAAKiB,gBAAgBD,KAAKhB,MACjDA,KAAKkB,aAAelB,KAAKkB,aAAaF,KAAKhB,MAC3CA,KAAKmB,YAAcnB,KAAKmB,YAAYH,KAAKhB,MACzCA,KAAKoB,YAAcpB,KAAKoB,YAAYJ,KAAKhB,QA5B7C,2BA+BOG,GACHH,KAAKqB,kBAGLC,OAAOC,iBAAiB,SAAUvB,KAAKkB,cACvClB,KAAKwB,aACLxB,KAAKyB,cAActB,GACnBH,KAAK0B,cACe,IAAIC,IAAY3B,KAAK4B,SAAU5B,KAAK6B,MAAO7B,KAAK8B,QACpE9B,KAAK+B,cACD/B,KAAKC,aACPD,KAAKgC,eAEPhC,KAAKiC,WACLjC,KAAKkC,gBAMLlC,KAAKmC,SAAS,IAAK,KACnBnC,KAAKoC,cAAc,MApDvB,+BAuDW,WACPpC,KAAKqC,SAASC,SACdtC,KAAKuC,sBACLvC,KAAK4B,SAAShB,OAAOZ,KAAK6B,MAAO7B,KAAK8B,QAItCU,uBAAsB,kBAAM,EAAK5B,cA9DrC,sCAkEI,IAAM6B,EAAOpD,SAASC,cAAc,QAC/BmD,GACHC,MAAM,oEAER,IAAMC,EAAMtD,SAASuD,cAAc,OACnCD,EAAIE,aAAa,QAAS,WAC1BF,EAAIE,aAAa,UAAW,WAC5BJ,EAAK3B,YAAY6B,GACjB3C,KAAK8C,QAAUH,IA1EnB,wCA6EoB,WAChB3C,KAAK+C,WAAa1D,SAASe,eAAe,eAC1C4C,QAAQC,IAAI,aAAcjD,KAAK+C,YAE3BG,UAAUC,cAAgBD,UAAUC,aAAaC,aAKnDF,UAAUC,aACPC,aALe,CAChBC,MAAO,CAAEC,MAAO,KAAMC,OAAQ,IAAKC,WAAY,UAK9CC,MAAK,SAAAC,GACJV,QAAQC,IAAI,aAAc,EAAKF,YAE/B,EAAKA,WAAWY,UAAYD,EAC5B,EAAKX,WAAWa,UAEjBC,OAAM,SAASC,GACdd,QAAQc,MAAM,sCAAuCA,MAGzDd,QAAQc,MAAM,2CAlGpB,kCAsGcC,MAtGd,sCAoHkBA,GAAO,QACN/D,KAAKgE,kBAAkBD,GADjB,eApHzB,mCAwHeA,GAAO,MAEoB/D,KAAKK,UAAnC4D,EAFU,EAEVA,YAAaC,EAFH,EAEGA,aACrBlE,KAAK8B,OAAOqC,OAASF,EAAcC,EACnClE,KAAK8B,OAAOsC,yBACZpE,KAAK4B,SAASyC,QAAQJ,EAAaC,KA7HvC,kCAgIcI,GAAkB,MACCA,EAAiBC,OAAtCC,EADoB,EACpBA,KAAYC,GADQ,EACdC,KADc,EACRD,MADQ,EAEXH,EAAiBK,KAAKC,OAA/BC,EAFoB,EAEpBA,EAAGC,EAFiB,EAEjBA,EAFiB,IAGD9E,KAAK+E,qBAAqBF,EAAGC,GAH5B,GAGrBE,EAHqB,KAGZC,EAHY,KAI5BjF,KAAK8C,QAAQoC,UAAb,cAAgCV,EAAhC,aAAyCC,EAAzC,mDACA,IAAMU,EAAQ,SAAH,OAAYH,EAAZ,oBAA+BC,EAA/B,yCACXjF,KAAK8C,QAAQqC,MAAQA,IAtIzB,kCAyIcb,GACVtE,KAAK8C,QAAQqC,MAAQ,uBA1IzB,mCAkJInF,KAAK6B,MAAQ,IAAIrB,QACjBR,KAAK6B,MAAMuD,YAAa,EAIxB,IAAMD,EAAQ7D,OAAO+D,iBAAiBrF,KAAKK,WACrCiF,EAAQ,IAAI9E,QAAY2E,EAAMI,iBAAiB,qBACrDvF,KAAK6B,MAAM2D,WAAaF,EACxBtF,KAAK6B,MAAM4D,IAAM,KAEjBzF,KAAK6B,MAAM2C,KAAO,sBA5JtB,oCAqKgBrE,GACZH,KAAK4B,SAAW,IAAIpB,gBAAoB,CACtCkF,WAAW,EACXvF,WAGFH,KAAK4B,SAAS+D,cAAc,SAC5B3F,KAAK4B,SAASgE,cAActE,OAAOuE,kBAAoB,GAPnC,MAQkB7F,KAAKK,UAAnC4D,EARY,EAQZA,YAAaC,EARD,EAQCA,aACrBlE,KAAK4B,SAASyC,QAAQJ,EAAaC,GACnClE,KAAK4B,SAASkE,UAAUC,SAAU,EAClC/F,KAAKK,UAAUS,YAAYd,KAAK4B,SAASoE,YACzChG,KAAK4B,SAASoE,WAAWzE,iBAAiB,QAASvB,KAAKe,aACxDf,KAAK4B,SAASoE,WAAWzE,iBACvB,YACAvB,KAAKiB,mBApLX,oCAyLI,IADY,EAE0BjB,KAAKK,UACrC8D,EAHM,EAEJF,YAFI,EAESC,aAIrBlE,KAAK8B,OAAS,IAAItB,oBALN,GAKmC2D,EAFlC,GACD,KAGZnE,KAAK8B,OAAO0C,KArMI,qBAsMhBxE,KAAK8B,OAAOmE,SAASC,IAAI,IAAK,IAAK,KACnClG,KAAK8B,OAAOqE,OAAOnG,KAAK6B,MAAMoE,YAlMlC,oCAsMI,IAAMG,EAAW,IAAI5F,mBAAuB,QAAU,GACtD4F,EAAS5B,KA3MkB,oBA4M3B4B,EAASH,SAASC,IAAI,IAAK,IAAK,KAChCE,EAASC,YAAa,EACtBD,EAASE,OAAOxE,OAAOyE,KAAO,GAC9BvG,KAAK6B,MAAM2E,IAAIJ,GAEf,IAAMK,EAAY,IAAIjG,YAAgB,UACtCiG,EAAUjC,KAjNU,YAkNpBiC,EAAUR,SAASC,IAAI,IAAK,GAAI,GAChCO,EAAUJ,YAAa,EACvBD,EAASE,OAAOxE,OAAOyE,KAAO,GAC9BvG,KAAK6B,MAAM2E,IAAIC,GAEf,IAAMC,EAAe,IAAIlG,eAAmB,UAC5CR,KAAK6B,MAAM2E,IAAIE,KArNnB,qCAyNI,IAAMC,EAAa,IAAInG,aAAiB,IAAK,IAC7CmG,EAAWnC,KAAO,mBAClBxE,KAAK6B,MAAM2E,IAAIG,GAGf,IAAMC,EAAa,IAAIpG,aAAiB,IACxCoG,EAAWpC,KAAO,iBAClBxE,KAAK6B,MAAM2E,IAAII,GAEf,IAAMR,EAAWpG,KAAK6B,MAAMgF,gBAtOD,qBAwOJ,IAAIrG,yBAA6B4F,EAAU,IACnD5B,KAAf,UAzO2B,oBAyO3B,WAG6B,IAAIhE,eAAmB4F,EAASE,OAAOxE,QAC/C0C,KAArB,UA7O2B,oBA6O3B,yBAGA,IAAMiC,EAAYzG,KAAK6B,MAAMgF,gBA/OT,aAiPI,IAAIrG,kBAAsBiG,GAClCjC,KAAhB,UAlPoB,YAkPpB,WAG8B,IAAIhE,eAChCiG,EAAUH,OAAOxE,QAEG0C,KAAtB,UAxPoB,YAwPpB,2BArPJ,iCA0PIxE,KAAK8G,UAAY,IAAItG,cA1PzB,+BAkQW8C,EAAOC,GAAQ,WAChBwD,EAAW,IAAIvG,gBAAoB8C,EAAOC,EAAQ,EAAG,GAyB3DvD,KAAKO,cAAcyG,KAAKvH,GAxBT,SAAAwH,GACbA,EAAQC,MAAQ1G,iBAChByG,EAAQE,MAAQ3G,iBAChByG,EAAQG,OAAOlB,IAAI,EAAG,GACtB,IAAMmB,EAAW,IAAI7G,oBAAwB,CAC3C8G,IAAKL,EACLM,KAAM/G,eAEFgH,EAAQ,IAAIhH,OAAWuG,EAAUM,GACvCG,EAAMhD,KAAO,QACbgD,EAAMvB,SAASnB,GAAK,GACpB0C,EAAMC,SAAS5C,EAAI6C,KAAKC,GAAK,EAC7B,EAAK9F,MAAM2E,IAAIgB,GAEfA,EAAMI,OAAS,UACfJ,EAAMK,GAAG,YAAa,EAAK1G,aAC3BqG,EAAMK,GAAG,WAAY,EAAKzG,oBAGTlB,GAEH,SAAA6D,GACdrB,MAAM,kCAAD,OAAmCjD,SA1R9C,sCAgSIO,KAAKqC,SAAW,IAAIyF,IAAc9H,KAAK8B,OAAQ9B,KAAK4B,SAASoE,YAC7DhG,KAAKqC,SAAS0D,SAAU,EACxB/F,KAAKqC,SAAS0F,YAAc,KAC5B/H,KAAKqC,SAAS2F,YAAc,EAC5BhI,KAAKqC,SAAS4F,YAAa,IApS/B,iCAwSI,IAAMC,EAAM,IAAIC,MAChBD,EACG1B,IAAIxG,KAAK8B,OAAOmE,SAAU,KAC1BzB,KAAK,YACL4D,IAAI,GACJC,IAAI,KACPH,EACG1B,IAAIxG,KAAK8B,OAAOmE,SAAU,KAC1BzB,KAAK,YACL4D,IAAI,GACJC,IAAI,KACPH,EACG1B,IAAIxG,KAAK8B,OAAOmE,SAAU,KAC1BzB,KAAK,YACL4D,IAAI,GACJC,IAAI,OAvTX,sCA8TIrI,KAAKsI,MAAQ,EACb,IAIMjB,EAAW,IAAI7G,iBAAqB,CACxCZ,eACAC,iBACA0I,SAPqB,CACrBD,MAAO,CAAEE,MAAO,MASZzB,EAAW,IAAIvG,uBAA2B,EAAG,GAAI,IAEvDR,KAAKyI,mBAAqB,IAAIC,aAC5B3B,EAAS4B,WAAW1C,SAAS2C,OAE/B,IAAK,IAAIC,EAAI,EAAGA,EAAI7I,KAAKyI,mBAAmBK,OAAQD,GAAK,EACvD7I,KAAKyI,mBAAmBI,GAAKnB,KAAKqB,IAAIF,GAGxC9B,EAASlE,aACP,qBACA,IAAIrC,kBAAsBR,KAAKyI,mBAAoB,IAGrD,IAAMO,EAAa,IAAIxI,OAAWuG,EAAUM,GAC5C2B,EAAWxE,KA1VU,cA2VrBwE,EAAW/C,SAASC,IAAI,EAAG,EAAG,GAC9BlG,KAAK6B,MAAM2E,IAAIwC,KA1VnB,yCA8VIhJ,KAAKsI,OAAS,GACd,IAAMU,EAAahJ,KAAK6B,MAAMgF,gBAjWT,eAkWrBmC,EAAW3B,SAASkB,SAASD,MAAME,MAAQ,GAA6B,GAAvBd,KAAKqB,IAAI/I,KAAKsI,OAC/D,IAAK,IAAIO,EAAI,EAAGA,EAAI7I,KAAKyI,mBAAmBK,OAAQD,GAAK,EACvD7I,KAAKyI,mBAAmBI,GAAK,GAAiC,IAA3BnB,KAAKqB,IAAIF,EAAI7I,KAAKsI,OAIvDU,EAAWjC,SAAS4B,WAAWF,mBAAmBQ,aAAc,IAtWpE,8BAyWU1B,GACN,IAAMR,EAAW,IAAIvG,eAAmB+G,EAAMA,EAAMA,GAC9CF,EAAW,IAAI7G,sBAA0B,CAAE8E,MAAO,WAElD4D,EAAO,IAAI1I,OAAWuG,EAAUM,GACtC6B,EAAK1E,KAAO,OACZ0E,EAAKjD,SAASC,IAAI,EAAGqB,EAAO,EAAG,GAC/BvH,KAAK6B,MAAM2E,IAAI0C,GAEfA,EAAKtB,OAAS,UACdsB,EAAKrB,GAAG,YAAa7H,KAAKmB,aAC1B+H,EAAKrB,GAAG,WAAY7H,KAAKoB,eApX7B,oCAuXgB+H,GAAQ,WACdpC,EAAW,IAAIvG,mBAAuB2I,EAAQA,EAAQ,EAAG,IAE3DlC,EAAU,IAAIzG,eAAmBR,KAAK+C,YAC1CkE,EAAQC,MAAQ1G,sBAChByG,EAAQE,MAAQ3G,sBAChByG,EAAQmC,OAAQ,EAEhB,IAAM/B,EAAW,IAAI7G,oBAAwB,CAAE8G,IAAKL,IAC9CoC,EAAK,IAAI7I,OAAWuG,EAAUM,GACpCgC,EAAG7E,KAAO,qBACV6E,EAAG5B,SAASvB,IAAIwB,KAAKC,GAAK,GAAID,KAAKC,GAAK,EAAG,GAE3C,IAAM2B,EAAQ,IAAI9I,QAClB8I,EAAM9E,KAAO,kBACb8E,EAAM9C,IAAI6C,GACVC,EAAMrD,SAASC,IAAI,EAAGiD,EAAQ,GAC9BnJ,KAAK6B,MAAM2E,IAAI8C,GAEfD,EAAGzB,OAAS,UACZyB,EAAGxB,GAAG,YAAa7H,KAAKmB,aACxBkI,EAAGxB,GAAG,WAAY7H,KAAKoB,aAEvBpB,KAAK+C,WAAWxB,iBAAiB,cAAc,WAG7C,IAAMgI,EAAU,EAAKxG,WAAWyG,YAAc,EAAKzG,WAAW0G,WAE9DxC,EAAQG,OAAOlB,IAAIqD,EADH,GAEhBtC,EAAQyC,OAAO7E,EAAI,SApZzB,4CAyZe7E,KAAK6B,MAAMgF,gBAAgB,mBACnCV,OAAOnG,KAAK8B,OAAOmE,YA1Z1B,wCAmaoB0D,EAAcC,EAAcC,GAAe,WACrD9C,EAAW,IAAIvG,WACfsJ,EAAYC,MAAMJ,GACrBK,KAAKH,GACLvC,IAAI2C,GACPlD,EAASmD,SAAWJ,EA4BpB9J,KAAKO,cAAcyG,KAAKrH,GA1BT,SAAAsH,GACb,IAAMI,EAAW,IAAI7G,iBAAqB,CAGxC2J,UAAW,GACX7C,IAAKL,EACLmD,KAAMR,EACNS,aAAa,IAGTC,EAAiB,IAAI9J,SAAauG,EAAUM,GAClDiD,EAAe9F,KAAO,QACtB8F,EAAerE,SAASC,KAAK,GAAI,IAAK,IACtC,EAAKrE,MAAM2E,IAAI8D,GAEfA,EAAe1C,OAAS,UACxB0C,EAAezC,GAAG,YAAa,EAAK1G,aACpCmJ,EAAezC,GAAG,WAAY,EAAKzG,oBAGlBlB,GAEH,SAAA6D,GACdrB,MAAM,kCAAD,OAAmC/C,SAjc9C,qCA0ciB4K,EAAUC,GACvB,IAAMlB,EAAQ,IAAI9I,QAClB8I,EAAM9E,KAAO,iBAFoB,IAGzBiG,EAAiCD,EAAjCC,MAAOlH,EAA0BiH,EAA1BjH,OAAQmH,EAAkBF,EAAlBE,OAAQpH,EAAUkH,EAAVlH,MACzByD,EAAW,IAAIvG,cAAkB8C,EAAOC,EAAQkH,GAEhDE,EAASZ,MAAMQ,GAClBP,KAAK,CAAEjD,WAAU2D,WACjBpD,IAAIsD,GAR0B,uBASjC,YAAmBD,EAAnB,+CAA2B,KAAhBE,EAAgB,QACzBvB,EAAM9C,IAAIqE,IAVqB,kFAYjCvB,EAAMrD,SAASC,IAAI,GAAI,GAAI,IAC3BlG,KAAK6B,MAAM2E,IAAI8C,GAEfA,EAAM1B,OAAS,UACf0B,EAAMzB,GAAG,YAAa7H,KAAKmB,aAC3BmI,EAAMzB,GAAG,WAAY7H,KAAKoB,eA3d9B,wCAkeoB2C,EAAO+G,GAAO,MAM1B9K,KAAK4B,SAASoE,WAJhB9B,EAF4B,EAE5BA,aACAD,EAH4B,EAG5BA,YACA8G,EAJ4B,EAI5BA,WACAC,EAL4B,EAK5BA,UAGIC,EAAclH,EAAMmH,QAAUH,EAC9BlG,EAAKoG,EAAchH,EAAe,EAAI,EAEtCkH,EAAcpH,EAAMqH,QAAUJ,EAC9BlG,GAAMqG,EAAcjH,EAAgB,EAAI,EAE9C,GAAI4G,EAAO,CACT,IAAMnG,EAAO,CACX,qBAAsB,CAAEE,EAAGd,EAAMsH,QAASvG,EAAGf,EAAMuH,SACnD,8BAA+B,CAAEzG,EAAGoG,EAAanG,EAAGqG,GACpD,qBAAsB,CAAEtG,IAAGC,MAE7B9B,QAAQuI,MAAM5G,EAAM,CAAC,IAAK,MAE5B,MAAO,CAACE,EAAGC,KAxff,2CA2fuB0G,EAAMC,GASzB,IAAMhJ,EAAOpD,SAASC,cAAc,8BAE9BoM,EAAgB1L,KAAKG,OAAOwL,wBAC5BC,EAAcnJ,EAAKkJ,wBAEnB9G,EAAI6G,EAAc7G,EAAI+G,EAAY/G,EAClCC,EAAI4G,EAAc5G,EAAI8G,EAAY9G,EAWxC,MAAO,EAJe0G,EAAO,GAAK,EAAKE,EAAcpI,MAEvBuB,GADT,IAAO4G,EAAO,GAAKC,EAAcnI,OAExBuB,Q,2BAphBlC,KA4hBA,SAASmF,EAAa4B,EAAGhD,GACvB,IAAMiD,EAAW,IAAItL,UAIrB,OAHAsL,EAASjH,EAAIrE,OAAWuL,gBAAgBF,EAAEnB,OAAO7F,GACjDiH,EAAShH,EAAItE,OAAWuL,gBAAgBF,EAAEnB,OAAO5F,GACjDgH,EAASE,EAAIxL,OAAWuL,gBAAgBF,EAAEnB,OAAOsB,GAC1CF,EAMT,SAASlB,EAASiB,EAAGhD,GACnB,IAAMxB,EAAW,IAAI7G,sBAA0B,CAC7C8E,MAAuB,SAAhBoC,KAAKuE,WAERpB,EAAO,IAAIrK,OAAWqL,EAAE9E,SAAUM,GAQxC,OAPAwD,EAAKrG,KAAL,cAAmBqE,EAAnB,mBACAgC,EAAK5E,SAASpB,EAAIrE,OAAWuL,gBAAgBF,EAAEnB,OAAO7F,GACtDgG,EAAK5E,SAASnB,EAAItE,OAAWuL,gBAAgBF,EAAEnB,OAAO5F,GACtD+F,EAAK5E,SAAS+F,EAAIxL,OAAWuL,gBAAgBF,EAAEnB,OAAOsB,GACtDnB,EAAKpD,SAAS5C,EAAoB,IAAhB6C,KAAKuE,UAAkBvE,KAAKC,GAAK,KACnDkD,EAAKpD,SAAS3C,EAAoB,IAAhB4C,KAAKuE,UAAkBvE,KAAKC,GAAK,KACnDkD,EAAKpD,SAASuE,EAAoB,IAAhBtE,KAAKuE,UAAkBvE,KAAKC,GAAK,KAC5CkD,I,gCCrkBT,sFAMAvJ,OAAOlC,gBAAkBA,IAEzBkC,OAAO4K,IAAM,IAAIpM,IACjBwB,OAAO6K,GAAK7K,OAAO4K,IAAIrK,MAAMgF,gBAAgB,mBAE7CvF,OAAOd,MAAQA,EAIfwC,QAAQC,IAAImJ,KAEZxH,EAAOyH,GAAKA,IACZrJ,QAAQC,IAAI,KAAMoJ,KAElB,IAAIC,EAAa,IAAIF,IACrB9K,OAAOgL,WAAaA,EAGpBA,EAAWC,UAAY,gDAGvBD,EAAWE,QAAU,CACnBC,OAAO,EACPpJ,OAAO,GAETiJ,EAAWI,gBAAkBrN,SAASe,eAAe,UAErDkM,EAAWK,WAAW,iB,qCCjCtBC,EAAOC,QAAU,IAA0B,8D,mBCA3CD,EAAOC,QAAU,IAA0B,sD,iBCA3CD,EAAOC,QAAU,qa,iBCAjBD,EAAOC,QAAU,sQ","file":"home.5366e8782dd4603b25c1.js","sourcesContent":["/**\n * Toggle display of the navbar dropdown for small screens.\n */\nexport function toggleMobileNav() {\n  const nav = document.querySelector(\"nav\");\n  nav.classList.toggle(\"nav-grid--expanded\");\n}\n","import * as THREE from \"three\";\n// TODO: OrbitControls import three.js on its own, so the webpack bundle includes three.js twice!\nimport OrbitControls from \"orbit-controls-es6\";\nimport { Interaction } from \"three.interaction\";\n\nimport * as Detector from \"../js/vendor/Detector\";\nimport * as DAT from \"../js/vendor/dat.gui.min\";\n\nconst checkerboard = require(\"../textures/checkerboard.jpg\");\nconst star = require(\"../textures/star.png\");\nconst vertexShader = require(\"../glsl/vertexShader.glsl\");\nconst fragmentShader = require(\"../glsl/fragmentShader.glsl\");\n\nconst CAMERA_NAME = \"Perspective Camera\";\nconst DIRECTIONAL_LIGHT_NAME = \"Directional Light\";\nconst SPOT_LIGHT_NAME = \"Spotlight\";\nconst CUSTOM_MESH_NAME = \"Custom Mesh\";\n\nexport class Application {\n  constructor(opts) {\n    this.showHelpers =\n      opts && opts.showHelpers !== undefined ? opts.showHelpers : true;\n    this.canvas = document.getElementById(\"application-canvas\");\n    this.container = document.querySelector(\"main .canvas-container-inner\");\n    this.createTooltip();\n    this.textureLoader = new THREE.TextureLoader();\n\n    if (Detector.webgl) {\n      this.bindEventHandlers();\n      this.init(this.canvas);\n      this.render();\n    } else {\n      // console.warn(\"WebGL NOT supported in your browser!\");\n      const warning = Detector.getWebGLErrorMessage();\n      this.container.appendChild(warning);\n    }\n  }\n\n  /**\n   * Bind event handlers to the Application instance.\n   */\n  bindEventHandlers() {\n    this.handleClick = this.handleClick.bind(this);\n    this.handleMouseMove = this.handleMouseMove.bind(this);\n    this.handleResize = this.handleResize.bind(this);\n    this.showTooltip = this.showTooltip.bind(this);\n    this.hideTooltip = this.hideTooltip.bind(this);\n  }\n\n  init(canvas) {\n    this.setupLocalVideo();\n\n    const showGUI = false;\n    window.addEventListener(\"resize\", this.handleResize);\n    this.setupScene();\n    this.setupRenderer(canvas);\n    this.setupCamera();\n    const interaction = new Interaction(this.renderer, this.scene, this.camera);\n    this.setupLights();\n    if (this.showHelpers) {\n      this.setupHelpers();\n    }\n    this.setupRay();\n    this.setupControls();\n\n    if (showGUI) {\n      this.setupGUI();\n    }\n\n    this.addFloor(100, 100);\n    this.addVideoGroup(20);\n  }\n\n  render() {\n    this.controls.update();\n    this.updateVideoCylinder();\n    this.renderer.render(this.scene, this.camera);\n    // when render is invoked via requestAnimationFrame(this.render) there is\n    // no 'this', so either we bind it explicitly or use an es6 arrow function.\n    // requestAnimationFrame(this.render.bind(this));\n    requestAnimationFrame(() => this.render());\n  }\n\n  createTooltip() {\n    const main = document.querySelector(\"main\");\n    if (!main) {\n      alert(`You have no '<main>' tag on ythe HTML page. You need exactly ONE`);\n    }\n    const div = document.createElement(\"div\");\n    div.setAttribute(\"class\", \"tooltip\");\n    div.setAttribute(\"data-cy\", \"tooltip\");\n    main.appendChild(div);\n    this.tooltip = div;\n  }\n\n  setupLocalVideo() {\n    this.localVideo = document.getElementById(\"local-video\");\n    console.log(\"localVideo\", this.localVideo);\n\n    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n      var constraints = {\n        video: { width: 1280, height: 720, facingMode: \"user\" },\n      };\n\n      navigator.mediaDevices\n        .getUserMedia(constraints)\n        .then(stream => {\n          console.log(\"localVideo\", this.localVideo);\n          // apply the stream to the video element used in the texture\n          this.localVideo.srcObject = stream;\n          this.localVideo.play();\n        })\n        .catch(function(error) {\n          console.error(\"Unable to access the camera/webcam.\", error);\n        });\n    } else {\n      console.error(\"MediaDevices interface not available.\");\n    }\n  }\n\n  handleClick(event) {\n    // const [x, y] = this.getNDCCoordinates(event, true);\n    // this.raycaster.setFromCamera({ x, y }, this.camera);\n    // const intersects = this.raycaster.intersectObjects(this.scene.children);\n    // if (intersects.length > 0) {\n    //   const hexColor = Math.random() * 0xffffff;\n    //   const intersection = intersects[0];\n    //   intersection.object.material.color.setHex(hexColor);\n    //   const { direction, origin } = this.raycaster.ray;\n    //   const arrow = new THREE.ArrowHelper(direction, origin, 100, hexColor);\n    //   this.scene.add(arrow);\n    // }\n  }\n\n  handleMouseMove(event) {\n    const [x, y] = this.getNDCCoordinates(event);\n  }\n\n  handleResize(event) {\n    // console.warn(event);\n    const { clientWidth, clientHeight } = this.container;\n    this.camera.aspect = clientWidth / clientHeight;\n    this.camera.updateProjectionMatrix();\n    this.renderer.setSize(clientWidth, clientHeight);\n  }\n\n  showTooltip(interactionEvent) {\n    const { name, uuid, type } = interactionEvent.target;\n    const { x, y } = interactionEvent.data.global;\n    const [xScreen, yScreen] = this.getScreenCoordinates(x, y);\n    this.tooltip.innerHTML = `<h4>${name} (${type})</h4><span><em>Click to cast a ray</em></span>`;\n    const style = `left: ${xScreen}px; top: ${yScreen}px; visibility: visible; opacity: 0.8`;\n    this.tooltip.style = style;\n  }\n\n  hideTooltip(interactionEvent) {\n    this.tooltip.style = \"visibility: hidden\";\n  }\n\n  /**\n   * Setup a Three.js scene.\n   * Setting the scene is the first Three.js-specific code to perform.\n   */\n  setupScene() {\n    this.scene = new THREE.Scene();\n    this.scene.autoUpdate = true;\n    // Let's say we want to define the background color only once throughout the\n    // application. This can be done in CSS. So here we use JS to get a property\n    // defined in a CSS.\n    const style = window.getComputedStyle(this.container);\n    const color = new THREE.Color(style.getPropertyValue(\"background-color\"));\n    this.scene.background = color;\n    this.scene.fog = null;\n    // Any Three.js object in the scene (and the scene itself) can have a name.\n    this.scene.name = \"My Three.js Scene\";\n  }\n\n  /**\n   * Create a Three.js renderer.\n   * We let the renderer create a canvas element where to draw its output, then\n   * we set the canvas size, we add the canvas to the DOM and we bind event\n   * listeners to it.\n   */\n  setupRenderer(canvas) {\n    this.renderer = new THREE.WebGLRenderer({\n      antialias: true,\n      canvas,\n    });\n    // this.renderer.setClearColor(0xd3d3d3);  // it's a light gray\n    this.renderer.setClearColor(0x222222); // it's a dark gray\n    this.renderer.setPixelRatio(window.devicePixelRatio || 1);\n    const { clientWidth, clientHeight } = this.container;\n    this.renderer.setSize(clientWidth, clientHeight);\n    this.renderer.shadowMap.enabled = true;\n    this.container.appendChild(this.renderer.domElement);\n    this.renderer.domElement.addEventListener(\"click\", this.handleClick);\n    this.renderer.domElement.addEventListener(\n      \"mousemove\",\n      this.handleMouseMove\n    );\n  }\n\n  setupCamera() {\n    const fov = 75;\n    const { clientWidth, clientHeight } = this.container;\n    const aspect = clientWidth / clientHeight;\n    const near = 0.1;\n    const far = 10000;\n    this.camera = new THREE.PerspectiveCamera(fov, aspect, near, far);\n    // this.camera = new THREE.PerspectiveCamera(fov, aspect, near, far);\n    this.camera.name = CAMERA_NAME;\n    this.camera.position.set(100, 100, 100);\n    this.camera.lookAt(this.scene.position);\n  }\n\n  setupLights() {\n    const dirLight = new THREE.DirectionalLight(0x4682b4, 1); // steelblue\n    dirLight.name = DIRECTIONAL_LIGHT_NAME;\n    dirLight.position.set(120, 30, -200);\n    dirLight.castShadow = true;\n    dirLight.shadow.camera.near = 10;\n    this.scene.add(dirLight);\n\n    const spotLight = new THREE.SpotLight(0xffaa55);\n    spotLight.name = SPOT_LIGHT_NAME;\n    spotLight.position.set(120, 30, 0);\n    spotLight.castShadow = true;\n    dirLight.shadow.camera.near = 10;\n    this.scene.add(spotLight);\n\n    const ambientLight = new THREE.AmbientLight(0xffaa55);\n    this.scene.add(ambientLight);\n  }\n\n  setupHelpers() {\n    const gridHelper = new THREE.GridHelper(200, 16);\n    gridHelper.name = \"Floor GridHelper\";\n    this.scene.add(gridHelper);\n\n    // XYZ axes helper (XYZ axes are RGB colors, respectively)\n    const axesHelper = new THREE.AxesHelper(75);\n    axesHelper.name = \"XYZ AzesHelper\";\n    this.scene.add(axesHelper);\n\n    const dirLight = this.scene.getObjectByName(DIRECTIONAL_LIGHT_NAME);\n\n    const dirLightHelper = new THREE.DirectionalLightHelper(dirLight, 10);\n    dirLightHelper.name = `${DIRECTIONAL_LIGHT_NAME} Helper`;\n    // this.scene.add(dirLightHelper);\n\n    const dirLightCameraHelper = new THREE.CameraHelper(dirLight.shadow.camera);\n    dirLightCameraHelper.name = `${DIRECTIONAL_LIGHT_NAME} Shadow Camera Helper`;\n    // this.scene.add(dirLightCameraHelper);\n\n    const spotLight = this.scene.getObjectByName(SPOT_LIGHT_NAME);\n\n    const spotLightHelper = new THREE.SpotLightHelper(spotLight);\n    spotLightHelper.name = `${SPOT_LIGHT_NAME} Helper`;\n    // this.scene.add(spotLightHelper);\n\n    const spotLightCameraHelper = new THREE.CameraHelper(\n      spotLight.shadow.camera\n    );\n    spotLightCameraHelper.name = `${SPOT_LIGHT_NAME} Shadow Camera Helper`;\n    // this.scene.add(spotLightCameraHelper);\n  }\n\n  setupRay() {\n    this.raycaster = new THREE.Raycaster();\n  }\n\n  /**\n   * Add a floor object to the scene.\n   * Note: Three.js's TextureLoader does not support progress events.\n   * @see https://threejs.org/docs/#api/en/loaders/TextureLoader\n   */\n  addFloor(width, height) {\n    const geometry = new THREE.PlaneGeometry(width, height, 1, 1);\n    const onLoad = texture => {\n      texture.wrapS = THREE.RepeatWrapping;\n      texture.wrapT = THREE.RepeatWrapping;\n      texture.repeat.set(4, 4);\n      const material = new THREE.MeshBasicMaterial({\n        map: texture,\n        side: THREE.DoubleSide,\n      });\n      const floor = new THREE.Mesh(geometry, material);\n      floor.name = \"Floor\";\n      floor.position.y = -0.5;\n      floor.rotation.x = Math.PI / 2;\n      this.scene.add(floor);\n\n      floor.cursor = \"pointer\";\n      floor.on(\"mouseover\", this.showTooltip);\n      floor.on(\"mouseout\", this.hideTooltip);\n    };\n\n    const onProgress = undefined;\n\n    const onError = event => {\n      alert(`Impossible to load the texture ${checkerboard}`);\n    };\n    this.textureLoader.load(checkerboard, onLoad, onProgress, onError);\n  }\n\n  setupControls() {\n    this.controls = new OrbitControls(this.camera, this.renderer.domElement);\n    this.controls.enabled = true;\n    this.controls.maxDistance = 1500;\n    this.controls.minDistance = 0;\n    this.controls.autoRotate = true;\n  }\n\n  setupGUI() {\n    const gui = new DAT.GUI();\n    gui\n      .add(this.camera.position, \"x\")\n      .name(\"Camera X\")\n      .min(0)\n      .max(100);\n    gui\n      .add(this.camera.position, \"y\")\n      .name(\"Camera Y\")\n      .min(0)\n      .max(100);\n    gui\n      .add(this.camera.position, \"z\")\n      .name(\"Camera Z\")\n      .min(0)\n      .max(100);\n  }\n\n  /**\n   * Create an object that uses custom shaders.\n   */\n  addCustomMesh() {\n    this.delta = 0;\n    const customUniforms = {\n      delta: { value: 0 },\n    };\n\n    const material = new THREE.ShaderMaterial({\n      vertexShader,\n      fragmentShader,\n      uniforms: customUniforms,\n    });\n\n    const geometry = new THREE.SphereBufferGeometry(5, 32, 32);\n\n    this.vertexDisplacement = new Float32Array(\n      geometry.attributes.position.count\n    );\n    for (let i = 0; i < this.vertexDisplacement.length; i += 1) {\n      this.vertexDisplacement[i] = Math.sin(i);\n    }\n\n    geometry.setAttribute(\n      \"vertexDisplacement\",\n      new THREE.BufferAttribute(this.vertexDisplacement, 1)\n    );\n\n    const customMesh = new THREE.Mesh(geometry, material);\n    customMesh.name = CUSTOM_MESH_NAME;\n    customMesh.position.set(5, 5, 5);\n    this.scene.add(customMesh);\n  }\n\n  updateCustomMesh() {\n    this.delta += 0.1;\n    const customMesh = this.scene.getObjectByName(CUSTOM_MESH_NAME);\n    customMesh.material.uniforms.delta.value = 0.5 + Math.sin(this.delta) * 0.5;\n    for (let i = 0; i < this.vertexDisplacement.length; i += 1) {\n      this.vertexDisplacement[i] = 0.5 + Math.sin(i + this.delta) * 0.25;\n    }\n    // attribute buffers are not refreshed automatically. To update custom\n    // attributes we need to set the needsUpdate flag to true\n    customMesh.geometry.attributes.vertexDisplacement.needsUpdate = true;\n  }\n\n  addCube(side) {\n    const geometry = new THREE.CubeGeometry(side, side, side);\n    const material = new THREE.MeshLambertMaterial({ color: 0xfbbc05 });\n\n    const cube = new THREE.Mesh(geometry, material);\n    cube.name = \"Cube\";\n    cube.position.set(0, side / 2, 0);\n    this.scene.add(cube);\n\n    cube.cursor = \"pointer\";\n    cube.on(\"mouseover\", this.showTooltip);\n    cube.on(\"mouseout\", this.hideTooltip);\n  }\n\n  addVideoGroup(radius) {\n    const geometry = new THREE.CylinderGeometry(radius, radius, 2, 32);\n\n    var texture = new THREE.VideoTexture(this.localVideo);\n    texture.wrapS = THREE.ClampToEdgeWrapping;\n    texture.wrapT = THREE.ClampToEdgeWrapping;\n    texture.flipY = false;\n\n    const material = new THREE.MeshBasicMaterial({ map: texture });\n    const vc = new THREE.Mesh(geometry, material);\n    vc.name = \"LocalVideoCylinder\";\n    vc.rotation.set(Math.PI / 2, -Math.PI / 2, 0);\n\n    const group = new THREE.Group();\n    group.name = \"LocalVideoGroup\";\n    group.add(vc);\n    group.position.set(0, radius, 0);\n    this.scene.add(group);\n\n    vc.cursor = \"pointer\";\n    vc.on(\"mouseover\", this.showTooltip);\n    vc.on(\"mouseout\", this.hideTooltip);\n\n    this.localVideo.addEventListener(\"loadeddata\", () => {\n      // These values are fractions of 1 where 1 is covering the object precisely.\n      // repeatX / repeatY should be the inverse of w/h\n      const repeatX = this.localVideo.videoHeight / this.localVideo.videoWidth;\n      const repeatY = 1;\n      texture.repeat.set(repeatX, repeatY);\n      texture.offset.x = 0.25;\n    });\n  }\n\n  updateVideoCylinder() {\n    const vg = this.scene.getObjectByName(\"LocalVideoGroup\");\n    vg.lookAt(this.camera.position);\n  }\n\n  /**\n   * Add a particle system that uses the same texture for each particle.\n   * The texture is asynchronously loaded.\n   * Note: Three.js's TextureLoader does not support progress events.\n   * @see https://threejs.org/docs/#api/en/loaders/TextureLoader\n   */\n  addParticleSystem(numParticles, particleSize, particleSpecs) {\n    const geometry = new THREE.Geometry();\n    const particles = Array(numParticles)\n      .fill(particleSpecs)\n      .map(makeParticle);\n    geometry.vertices = particles;\n\n    const onLoad = texture => {\n      const material = new THREE.PointsMaterial({\n        // alphaTest's default is 0 and the particles overlap. Any value > 0\n        // prevents the particles from overlapping.\n        alphaTest: 0.5,\n        map: texture,\n        size: particleSize,\n        transparent: true,\n      });\n\n      const particleSystem = new THREE.Points(geometry, material);\n      particleSystem.name = \"Stars\";\n      particleSystem.position.set(-50, 50, -50);\n      this.scene.add(particleSystem);\n\n      particleSystem.cursor = \"pointer\";\n      particleSystem.on(\"mouseover\", this.showTooltip);\n      particleSystem.on(\"mouseout\", this.hideTooltip);\n    };\n\n    const onProgress = undefined;\n\n    const onError = event => {\n      alert(`Impossible to load the texture ${star}`);\n    };\n\n    this.textureLoader.load(star, onLoad, onProgress, onError);\n  }\n\n  /**\n   * Add a Three.js Group object to the scene.\n   */\n  addGroupObject(numBoxes, boxSpecs) {\n    const group = new THREE.Group();\n    group.name = \"Group of Boxes\";\n    const { depth, height, spread, width } = boxSpecs;\n    const geometry = new THREE.BoxGeometry(width, height, depth);\n\n    const meshes = Array(numBoxes)\n      .fill({ geometry, spread })\n      .map(makeMesh);\n    for (const mesh of meshes) {\n      group.add(mesh);\n    }\n    group.position.set(50, 20, 50);\n    this.scene.add(group);\n\n    group.cursor = \"pointer\";\n    group.on(\"mouseover\", this.showTooltip);\n    group.on(\"mouseout\", this.hideTooltip);\n  }\n\n  /**\n   * Convert screen coordinates into Normalized Device Coordinates [-1, +1].\n   * @see https://learnopengl.com/Getting-started/Coordinate-Systems\n   */\n  getNDCCoordinates(event, debug) {\n    const {\n      clientHeight,\n      clientWidth,\n      offsetLeft,\n      offsetTop,\n    } = this.renderer.domElement;\n\n    const xRelativePx = event.clientX - offsetLeft;\n    const x = (xRelativePx / clientWidth) * 2 - 1;\n\n    const yRelativePx = event.clientY - offsetTop;\n    const y = -(yRelativePx / clientHeight) * 2 + 1;\n\n    if (debug) {\n      const data = {\n        \"Screen Coords (px)\": { x: event.screenX, y: event.screenY },\n        \"Canvas-Relative Coords (px)\": { x: xRelativePx, y: yRelativePx },\n        \"NDC (adimensional)\": { x, y },\n      };\n      console.table(data, [\"x\", \"y\"]);\n    }\n    return [x, y];\n  }\n\n  getScreenCoordinates(xNDC, yNDC) {\n    // const {\n    //   clientHeight,\n    //   clientWidth,\n    //   offsetLeft,\n    //   offsetTop,\n    // } = this.renderer.domElement;\n\n    // TODO: save this.main at instantiation\n    const main = document.querySelector(\".single-responsive-element\");\n\n    const canvasDomRect = this.canvas.getBoundingClientRect();\n    const mainDomRect = main.getBoundingClientRect();\n    // console.log(\"canvasDomRect\", canvasDomRect, \"mainDomRect\", mainDomRect);\n    const x = canvasDomRect.x - mainDomRect.x;\n    const y = canvasDomRect.y - mainDomRect.y;\n\n    // const xRelativePx = ((xNDC + 1) / 2) * clientWidth;\n    // const yRelativePx = -0.5 * (yNDC - 1) * clientHeight;\n    // const xScreen = xRelativePx + offsetLeft;\n    // const yScreen = yRelativePx + offsetTop;\n    // TODO: this is not exactly right, so the ray will not be correct\n    const xRelativePx = ((xNDC + 1) / 2) * canvasDomRect.width;\n    const yRelativePx = -0.5 * (yNDC - 1) * canvasDomRect.height;\n    const xScreen = xRelativePx + x;\n    const yScreen = yRelativePx + y;\n    return [xScreen, yScreen];\n  }\n}\n\n/**\n * Create a particle for the particle system.\n */\nfunction makeParticle(d, i) {\n  const particle = new THREE.Vector3();\n  particle.x = THREE.Math.randFloatSpread(d.spread.x);\n  particle.y = THREE.Math.randFloatSpread(d.spread.y);\n  particle.z = THREE.Math.randFloatSpread(d.spread.z);\n  return particle;\n}\n\n/**\n * Make a mesh for each Box in the GroupObject.\n */\nfunction makeMesh(d, i) {\n  const material = new THREE.MeshLambertMaterial({\n    color: Math.random() * 0xffffff,\n  });\n  const mesh = new THREE.Mesh(d.geometry, material);\n  mesh.name = `Box ${i} in GroupObject`;\n  mesh.position.x = THREE.Math.randFloatSpread(d.spread.x);\n  mesh.position.y = THREE.Math.randFloatSpread(d.spread.y);\n  mesh.position.z = THREE.Math.randFloatSpread(d.spread.z);\n  mesh.rotation.x = Math.random() * 360 * (Math.PI / 180);\n  mesh.rotation.y = Math.random() * 360 * (Math.PI / 180);\n  mesh.rotation.z = Math.random() * 360 * (Math.PI / 180);\n  return mesh;\n}\n","import * as THREE from \"three\";\n\nimport { Application } from \"./application\";\nimport { toggleMobileNav } from \"./components/navbar\";\nimport \"../css/index.css\";\n\nwindow.toggleMobileNav = toggleMobileNav;\n\nwindow.app = new Application();\nwindow.vg = window.app.scene.getObjectByName(\"LocalVideoGroup\");\n\nwindow.THREE = THREE;\n\n// Video Chat Setup\nimport RTCMultiConnection from \"rtcmulticonnection\";\nconsole.log(RTCMultiConnection);\nimport io from \"socket.io-client\";\nglobal.io = io;\nconsole.log(\"io\", io);\n\nvar connection = new RTCMultiConnection();\nwindow.connection = connection;\n\n// this line is VERY_important\nconnection.socketURL = \"https://rtcmulticonnection.herokuapp.com:443/\";\n\n// if you want audio+video conferencing\nconnection.session = {\n  audio: true,\n  video: true,\n};\nconnection.videosContainer = document.getElementById(\"videos\");\n\nconnection.openOrJoin(\"your-room-id\");\n","module.exports = __webpack_public_path__ + \"textures/checkerboard.bda67ca60caae86413aec7e10112ac3e.jpg\";","module.exports = __webpack_public_path__ + \"textures/star.0875fc7146a00ddc30bb221db0dcef90.png\";","module.exports = \"attribute float vertexDisplacement;\\nuniform float delta;\\nvarying float vOpacity;\\nvarying vec3 vUv;\\n\\nvoid main() {\\n    vUv = position;\\n    vOpacity = vertexDisplacement;\\n\\n    vec3 p = position;\\n\\n    p.x += sin(vertexDisplacement) * 50.0;\\n    p.y += cos(vertexDisplacement) * 50.0;\\n\\n    vec4 modelViewPosition = modelViewMatrix * vec4(p, 1.0);\\n    gl_Position = projectionMatrix * modelViewPosition;\\n}\\n\"","module.exports = \"uniform float delta;\\nvarying float vOpacity;\\nvarying vec3 vUv;\\n\\nvoid main() {\\n    float r = 1.0 + cos(vUv.x * delta);\\n    float g = 0.5 + sin(delta) * 0.5;\\n    float b = 0.0;\\n    vec3 rgb = vec3(r, g, b);\\n\\n    gl_FragColor = vec4(rgb, vOpacity);\\n}\""],"sourceRoot":""}